/*** TextEngineLabel by gskinner.com. Nov 4, 2008* Visit www.gskinner.com/blog for documentation, updates and more free code.*** Copyright (c) 2008 Grant Skinner* * Permission is hereby granted, free of charge, to any person* obtaining a copy of this software and associated documentation* files (the "Software"), to deal in the Software without* restriction, including without limitation the rights to use,* copy, modify, merge, publish, distribute, sublicense, and/or sell* copies of the Software, and to permit persons to whom the* Software is furnished to do so, subject to the following* conditions:* * The above copyright notice and this permission notice shall be* included in all copies or substantial portions of the Software.* * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR* OTHER DEALINGS IN THE SOFTWARE.**/package com.gskinner.controls {		import fl.core.InvalidationType;	import fl.core.UIComponent;		import flash.text.engine.DigitCase;	import flash.text.engine.ElementFormat;	import flash.text.engine.FontDescription;	import flash.text.engine.FontWeight;	import flash.text.engine.Kerning;	import flash.text.engine.LigatureLevel;	import flash.text.engine.TextElement;	import flash.text.engine.TextRotation;	import flash.text.engine.TextBlock;	import flash.text.engine.TextLine;	import flash.text.engine.FontLookup;	import flash.text.TextFormatAlign;		import flash.display.Graphics;	public class TextEngineLabel extends UIComponent {				//Text engine variables		protected var txtBlock:TextBlock;		protected var textLine:TextLine;		protected var textElement:TextElement;		protected var elementFormat:ElementFormat;				//Protected Properties		protected var _text:String;				//Text Engine Properties		protected var _font:String = '_sans';		protected var _size:Number = 12;		protected var _fontWeight:String = FontWeight.NORMAL; //FontWeight.BOLD || FontWeight.NORMAL		protected var _color:uint = 0xffffff;		protected var _textRotation:String = TextRotation.ROTATE_0; //TextRotation.AUTO || TextRotation.ROTATE_0 || TextRotation.ROTATE_90 || TextRotation.ROTATE_180 || TextRotation.ROTATE_270		protected var _kerning:String = Kerning.ON; //Kerning.AUTO || Kerning.OFF || Kerning.ON		protected var _ligatureLevel:String = LigatureLevel.COMMON; //LigatureLevel.COMMON || LigatureLevel.EXOTIC || LigatureLevel.MINIMUM || LigatureLevel.NONE || LigatureLevel.UNCOMMON		protected var _digitCase:String = DigitCase.OLD_STYLE; //DigitCase.DEFAULT || DigitCase.LINING || DigitCase.OLD_STYLE		protected var _textAlign:String = TextFormatAlign.LEFT;		protected var _locale:String = 'en';		protected var _trackingLeft:Number = 0.0;		protected var _trackingRight:Number = 0.0;				public function TextEngineLabel() {			super();		}				[Inspectable(defaultValue="Label", type="String")]		public function set text(p_value:String):void {			_text = p_value;			invalidate(InvalidationType.DATA);		}		public function get text():String { return _text; }				[Inspectable(defaultValue="_sans", type="String")]		public function set font(p_value:String):void {			_font = p_value;			invalidate(InvalidationType.STYLES);		}		public function get font():String { return _font; }				[Inspectable(defaultValue="on", enumeration="auto,off,on", type="list")]		public function set kerning(p_value:String):void {			_kerning = p_value;			invalidate(InvalidationType.STYLES);		}		public function get kerning():String { return _kerning; }				[Inspectable(defaultValue="common", enumeration="common,exotic,minimum,none,uncommon", type="list")]		public function set ligatureLevel(p_value:String):void {			_ligatureLevel = p_value;			invalidate(InvalidationType.STYLES);		}		public function get ligatureLevel():String { return _ligatureLevel; }				[Inspectable(defaultValue="left", enumeration="left,center,right", type="list")]		public function set textAlign(p_value:String):void {			_textAlign = p_value;			invalidate(InvalidationType.STYLES);		}		public function get textAlign():String { return _textAlign; }				[Inspectable(defaultValue="rotate0", enumeration="rotate0,rotate90,rotate180,rotate270", type="list")]		public function set textRotation(p_value:String):void {			_textRotation = p_value;			invalidate(InvalidationType.STYLES);		}		public function get textRotation():String { return _textRotation; }				//DigitCase.DEFAULT || DigitCase.LINING || DigitCase.OLD_STYLE		[Inspectable(defaultValue="default", enumeration="lining,default,oldStyle", type="list")]		public function set digitCase(p_value:String):void {			_digitCase = p_value;			invalidate(InvalidationType.STYLES);		}		public function get digitCase():String { return _digitCase; }				[Inspectable(defaultValue="normal", enumeration="bold,normal", type="list")]		public function set fontWeight(p_value:String):void {			_fontWeight = p_value;			invalidate(InvalidationType.STYLES);		}		public function get fontWeight():String { return _fontWeight; }				[Inspectable(defaultValue="12", type="Number")]		public function set size(p_value:Number):void {			_size = p_value;			invalidate(InvalidationType.STYLES);		}		public function get size():Number { return _size; }				[Inspectable(defaultValue="#000000", type="Color")]		public function set color(p_value:Number):void {			_color = p_value;			invalidate(InvalidationType.STYLES);		}		public function get color():Number { return _color; }				[Inspectable(defaultValue="en", type="String")]		public function set locale(p_value:String):void {			_locale = p_value;			invalidate(InvalidationType.STYLES);		}		public function get locale():String { return _locale; }				[Inspectable(defaultValue="0", type="Number")]		public function set trackingLeft(p_value:Number):void {			_trackingLeft = p_value;			invalidate(InvalidationType.STYLES);		}		public function get trackingLeft():Number { return _trackingLeft; }				[Inspectable(defaultValue="0", type="Number")]		public function set trackingRight(p_value:Number):void {			_trackingRight = p_value;			invalidate(InvalidationType.STYLES);		}		public function get trackingRight():Number { return _trackingRight; }				public function get textWidth():Number {			return textLine!=null?textLine.textWidth:0;		}				override public function get height():Number { return textLine!=null?textLine.textHeight:0; }		override public function get width():Number { return textLine!=null?textLine.textWidth:0; }				override protected function draw():void {			if (isInvalid(InvalidationType.STYLES)) {				elementFormat = new ElementFormat();								var fd:FontDescription = new FontDescription(_font, _fontWeight);				//fd.fontLookup = FontLookup.EMBEDDED_CFF;								elementFormat.fontDescription = fd;				elementFormat.fontSize = _size;				elementFormat.color = _color;				elementFormat.kerning = _kerning;				elementFormat.ligatureLevel = _ligatureLevel;				elementFormat.digitCase = _digitCase;				elementFormat.textRotation = _textRotation;				elementFormat.alpha = alpha;				elementFormat.locale = _locale;				elementFormat.trackingLeft = _trackingLeft;				elementFormat.trackingRight = _trackingRight;								invalidate(InvalidationType.DATA);			}						if (isInvalid(InvalidationType.DATA, InvalidationType.STATE)) {				createText();			}						super.draw();		}				protected function createText():void {			if (txtBlock && textLine) {				removeChild(textLine);				txtBlock.releaseLines(textLine, textLine);			}						textElement = new TextElement(_text == null?'':_text, elementFormat);			txtBlock = new TextBlock(textElement);						textLine = txtBlock.createTextLine(null);						if (textLine != null) {				textLine.width = textLine.textWidth;				textLine.y = textLine.textHeight;								switch (_textAlign) {					case TextFormatAlign.CENTER:						textLine.x = _width - textLine.width>>1;						break;					case TextFormatAlign.LEFT:						textLine.x = 0;						break;					case TextFormatAlign.RIGHT:						textLine.x = _width - textLine.width;						break;				}								addChild(textLine);			}		}	}}