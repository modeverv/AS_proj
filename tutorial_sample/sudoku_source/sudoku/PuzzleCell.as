package sudoku {	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.text.TextFieldType;	import flash.text.TextFormat;	import flash.text.TextFormatAlign;	import flash.events.KeyboardEvent;	// This class extends TextField, to support one cell in the Sudoku grid.	// The field knows how to format itself, choosing font size according to the number of characters.	// A field can be read-only, for the original puzzle digits,	// or read/write, for the digits enetered by the player.	// Characters are limited to digits 1-9.	public class PuzzleCell extends TextField {		private const sizes:Array = [ 34, 34, 24, 24, 18, 18, 18, 18, 18, 15 ];		private const fontOrig:String = "Arial,Helvetica,Verdana";		private const sizeOrig:uint = 36;		private const colorOrig:uint = 0x000000;				private var tf:TextFormat;		private var tfInput:TextFormat;		private var answer:String;		public function PuzzleCell(cellnum:uint, xpos:Number, ypos:Number, cellSize:Number, str:String) 		{			name = "c" + cellnum;	// name the cell			x = xpos;	// position the cell			y = ypos;	// position the cell			// size same as cell size, so clicking will work			autoSize = TextFieldAutoSize.NONE;			width = cellSize;			height = cellSize;			background = false;			// make the text format			tf = new TextFormat(fontOrig, sizeOrig, colorOrig);			tf.align = TextFormatAlign.CENTER;			type = TextFieldType.INPUT;			text = str;			setFontSize();			// Attach event handlers			addEventListener(KeyboardEvent.KEY_UP, onKeyUp);		}				public function CellPopulate(flag:uint, char:String)		{			if (flag) {				type = TextFieldType.DYNAMIC;				tf.color = colorOrig;	// original cells have black text				tf.size = sizeOrig;			// original cells are 36 pts				text = "";				defaultTextFormat = tf;				text = char;				selectable = false;				background = false;			} else {				selectable = true;				type = TextFieldType.INPUT;				tabEnabled = true;				backgroundColor = 0xffdddd;				maxChars = 9;				multiline = true;				wordWrap = true;				restrict = "1-9";				answer = char;				tf.color = 0x6666ff;	// different color for these				CellClear();			}		}				// color incorrect cells		// return true if cell is correct (this includes non-selectable cells).		public function CellCheck():Boolean		{			var retVal:Boolean = true;			if (selectable) {				if (text.length != 1) {					retVal = false;				}				else if (answer != text) {					retVal = false;	// includes empties, multiples, and errors					background = true;				}			}			return retVal;		}				public function CellClear():void		{			if (selectable) {				text = "";				setFontSize();				background = false;			}		}				public function get value():String		{			return text;		}				public function set value(str:String):void		{			text = str;			setFontSize();		}		// ===============================================		//	Private Methods		// ===============================================		private function onKeyUp(event:KeyboardEvent):void 		{			if (text != null && text.length > 0) {				// choose fontsize according to number of digits (max = 9 chars)				setFontSize();			}			background = false;		}				private function setFontSize():void		{			// choose fontsize according to number of digits (max = 9 chars)			var startSel:int = selectionBeginIndex;			var endSel:int = selectionBeginIndex;			var numChars:uint = text.length;			var saveText:String = text;			if (numChars > 1) {				var sorted:String = "";				for (var i:uint=1; i<=9; i++) {					if (saveText.indexOf(String(i)) >= 0) {						sorted += i;					}				}				saveText = sorted;			}			text = "";			numChars = saveText.length;			tf.size = sizes[numChars];				tf.color = (numChars > 1) ? 0x6666FF : 0x0000FF;			// set the text format			defaultTextFormat = tf;			text = saveText;			setSelection(startSel, endSel);			/* This version causes a crash			// choose fontsize according to number of digits (max = 9 chars)			tf.size = sizes[text.length];							// set the text format			if (text.length > 0) {				setTextFormat(tf);			}			defaultTextFormat = tf;*/						}			}}