package sudoku {	import flash.display.Sprite;	import flash.display.DisplayObjectContainer;	import sudoku.PuzzleCell;		public class PuzzleBox extends Sprite {		private var cells:Array = new Array();		private var possBits:Array = new Array();		var searchIndices:Array = new Array();				private const numRows:uint = 9;		private const numCols:uint = 9;		private const numCells:uint = 81;		public function PuzzleBox(x:Number, y:Number, cellSize:Number, cellHeight:Number) 		{			var xpos:uint = x;			var ypos:uint = y; 			var cellnum:uint = 0;			var cell:PuzzleCell;			var str:String = "SUDOKU      SUDOKU";			while (cellnum < numCells) {				cell = new PuzzleCell(cellnum, xpos, ypos, cellSize, str.charAt(cellnum%str.length));				addChild(cell);				cells[cellnum] = cell;								cellnum++;				xpos += cellSize;				if (cellnum % numCols == 0) {					xpos = x;					ypos += cellSize;				}			}			makeSearchIndexArray();		}				public function Populate(answer:String, masks:String):void		{			var flag:uint;			var char:String			for (var cellnum:uint=0; cellnum<81; cellnum++) {				// A character which is a digit 1...9 in mask means it is an original digit in puzzle				var mask:int = masks.charCodeAt(cellnum);				flag = ((mask >= 0x31) && (mask <= 0x39)) ? mask : 0;				char = answer.charAt(cellnum);				cells[cellnum].CellPopulate(flag, char);			}		}						public function Reset():void		{			for (var i:uint=0; i<numCells; i++) {				cells[i].CellClear();			}		}				public function Check():int		{			// return # of correct cells			var numCorrect:uint = 0;			for (var i:uint=0; i<numCells; i++) {				numCorrect += cells[i].CellCheck() ? 1 : 0;			}			return numCorrect;		}		public function GetCellValue(cellnum:uint):String		{			return cells[cellnum].value;		}				public function SetCellValue(cellnum:uint, value:String):void		{			cells[cellnum].value = value;		}				public function Hide():void		{			for (var i:int=0; i<81; i++) {				cells[i].visible = false;			}		}				public function Show():void		{			for (var i:int=0; i<81; i++) {				cells[i].visible = true;			}		}				public function findPossibles():void		{			var possible:String;			var possMask:int;			var cellVal:String;						for (var i:int=0; i<81; i++) {				possBits[i] = 0;	// will get 1-bits for each possible				possMask = 1;				possible = "";				cellVal = cells[i].value;				if (cellVal.length != 1) {	// unknown cell					cells[i].value = "";					// try each possible digit to build string					for (var digit=1; digit<10; digit++) {						if (CheckRowColBox(i, digit)) {							possible += digit;							possBits[i] |= possMask;						}						possMask <<= 1;					}					cells[i].value = possible;				}			}		}			// look in each row, column, box for any value that can only be in one of the cells		public function findSingletons():void		{			do {				findPossibles();			} while (checkSingleton(0) || checkSingleton(9) || checkSingleton(18));			checkTwoPairs();		}			// ==================================================		//	Private Methods		// ==================================================				private const boxrowoffsets:Array = [ 0, 0, 1, 0, 0, 1, 0, 0, 1 ];		private const boxcoloffsets:Array = [ 1, 1, -2, 1, 1, -2, 1, 1, -2 ];				private function CheckRowColBox(cellnum:int, value:String):Boolean		{			// return true if value is possible in this cell			var retVal:Boolean = true;			var row:uint = cellnum/9;			var col:uint = cellnum%9;						var boxRow:int = row / 3;			var boxCol:int = col / 3;			var boxIndex:uint = boxRow * 27 + boxCol * 3;			var brow:uint = boxIndex/9;			var bcol:uint = boxIndex%9;									// test value in each position			for (var i=0; i<9; i++) {				if (cells[row*9+i].value == value					|| cells[i*9+col].value == value					|| cells[brow*9+bcol].value == value) {					retVal = false;					break;				}				brow += boxrowoffsets[i];				bcol += boxcoloffsets[i];			}					return retVal;		}		// does a given row or column or box have a singleton?		// start=0 for rows, start=9 for columns, start=18 for boxes		private function checkSingleton(start:int):Boolean		{			var anyChanges:Boolean = false;			var group:uint;			var cell_i:uint;			var cell_j:uint;			var d:uint;			var value_i:String;			var value_j:String;			for (group=start; group<start+9; group++) {				for (d=1; d<10; d++) {					var digit:String = String(d);					for (var i=0; i<9; i++) {						cell_i = searchIndices[group][i];						value_i = cells[cell_i].value;						if (value_i.length > 1 && value_i.indexOf(digit) >= 0) {							// found one cell containing digit, look for another							var foundSecond:Boolean = false;							for (var j=i+1; j<9; j++) {								cell_j = searchIndices[group][j];								value_j = cells[cell_j].value;								if (value_j.indexOf(digit) >= 0) {									foundSecond = true;									break;								}							}							if (!foundSecond) {								// we have a singleton in cell_i == digit										trace("Group "+group+" setting cell " + cell_i + " to " + digit);								cells[cell_i].value = digit;								anyChanges = true;							}							break;						}					}				}			}			return anyChanges;		}		// does a given row or column or box have ab/ab?		private function checkTwoPairs():void		{			var group:uint;			var cell_i:uint;			var cell_j:uint;			var cell_k:uint;			for (group=0; group<27; group++) {				// loop over first 8 in this group, looking for any pair "ab"				for (var i=0; i<8; i++) {					cell_i = searchIndices[group][i];					var value:String = cells[cell_i].value;					if (value.length == 2) {						// see if any others in same column with value "ab"						for (var j=i+1; j<9; j++) {							cell_j = searchIndices[group][j];							if (cells[cell_j].value == value) {								// have two pairs ab/ab				//				trace("checkTwoPairs: have two pairs " + value + " at col " + col + " row ",i,j);								// remove a and b from rest of this row								for (var k=0; k<9; k++) {									if (k != i && k != j) {										cell_k = searchIndices[group][k];										var originalValue:String = cells[cell_k].value;										if (originalValue.length != 1) {											var filter:RegExp = new RegExp("[" + value + "]", "g");											var filteredValue:String = originalValue.replace(filter, "");											if (originalValue != filteredValue) {				//								trace("row " + k + "original = " + originalValue + ", filtered = " + filteredValue);											}											cells[cell_k].value = filteredValue;										}									}								}								break;							}						}					}									}			}		}						// 27 vectors: 9 for the rows, 9 for the columns, 9 for the boxes		private function makeSearchIndexArray()		{			var boxOffset:Array = [0, 1, 2, 9, 10, 11, 18, 19, 20];			var boxStart:Array = [0,3,6, 27, 30, 33, 54, 57, 60];						for (var i:uint = 0; i<9; i++) {				searchIndices[i] = new Array();				searchIndices[i+9] = new Array();				searchIndices[i+18] = new Array();				for (var j:uint = 0; j<9; j++) {					searchIndices[i][j] = i*9 + j;	// rows					searchIndices[i+9][j] = i + j*9;		// columns					searchIndices[i+18][j] = boxStart[i] + boxOffset[j];				}			}		}	}}