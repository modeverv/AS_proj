<?xml version="1.0" encoding="utf-8"?>
<mx:Window xmlns:mx="http://www.adobe.com/2006/mxml" 
	xmlns:validators="jp.fores.common.validators.*"
	width="500" height="400"
	layout="absolute" 
	title="設定" 
	showStatusBar="false"
	showTitleBar="false"
	showGripper="false"
	resizable="false"
	maximizable="false"
	horizontalScrollPolicy="off"
	verticalScrollPolicy="off"
	cornerRadius="0"
	creationComplete="onCreationComplete()"
	closing="onClosing(event)"
	>

	<mx:Script>
		<![CDATA[
			import jp.fores.common.utils.TrayIconUtil;
			import jp.fores.common.utils.EventUtil;
			import jp.fores.foresmessenger.dto.UserInfoDto;
			import jp.fores.common.utils.ArrayUtil;
			import jp.fores.common.utils.StringUtil;
			import mx.events.ValidationResultEvent;
			import mx.events.FlexEvent;
			import jp.fores.common.utils.SelectionUtil;
			import mx.validators.Validator;
			import mx.core.Application;
			import jp.fores.foresmessenger.dto.ConfigDto;
			import jp.fores.foresmessenger.manager.MessengerManager;
			import mx.controls.Alert;
			import jp.fores.common.net.AIRRemoteUpdaterEvent;
			import mx.events.CloseEvent;
			import jp.fores.common.net.AIRRemoteUpdater;
			import jp.fores.foresmessenger.constant.ForesMessengerIconConstant;
			import jp.fores.foresmessenger.constant.ForesMessengerConstant;
			import mx.collections.ArrayCollection;
			
			//==========================================================
			//定数
			
			/**
			 * AIRファイルのURL
			 */
			public static const AIR_URL :String = "http://www.fores.jp/labs/air/ForesMessenger.air";
			
			
			//==========================================================
			//フィールド
			
			//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
			//クラスフィールド
			
			/**
			 * この画面が最初に開かれた状態かどうかのフラグ
			 */
			private static var isFirstOpen :Boolean = true;
			
			
			//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
			//インスタンスフィールド
			
			/**
			 * メッセンジャーのメインの管理クラス
			 */
			[Bindable]
			public var messengerManager :MessengerManager = MessengerManager.getInstance();
			
			/**
			 * バージョン情報タブを最初に表示するかどうかのフラグ
			 */
			public var isVersionTabFirstDisplay :Boolean = false;
			
			/**
			 * 自動ログインで自動バージョンチェックかどうかのフラグ
			 */
			public var isAutoLoginVersionCheck :Boolean = false;

			/**
			 * AIRアプリケーションのリモートアップデーター
			 */
			private var airRemoteUpdater :AIRRemoteUpdater = new AIRRemoteUpdater();
			
			/**
			 * ローカルバージョン
			 */
			[Bindable]
			private var localVersion :String = null;
			
			/**
			 * コピーライト
			 */
			[Bindable]
			private var copyright :String = null;
			
			/**
			 * アプリケーション名
			 */
			[Bindable]
			private var applicationName :String = null;
			
			/**
			 * グループのArrayCollection
			 */
			[Bindable]
			private var groupArrayCollection :ArrayCollection = new ArrayCollection();
			
			/**
			 * 着信通知を行うかどうかのフラグ
			 */
			[Bindable]
			private var receiveNotifyEnable :Boolean = true;
			
			/**
			 * ログイン通知を行うかどうかのフラグ
			 */
			[Bindable]
			private var loginNotifyEnable :Boolean = true;
			
			/**
			 * 開封通知を行うかどうかのフラグ
			 */
			[Bindable]
			private var openNotifyEnable :Boolean = true;
			
			/**
			 * ログイン処理を実行中かどうかのフラグ
			 */
			private var isLoginPlaying :Boolean = false;
			
			/**
			 * 起動時のバージョンチェックかどうかのフラグ
			 */
			private var isStartVersionCheck :Boolean = false;

			/**
			 * ログファイルのパスを選択するためのファイルオブジェクト
			 */
			private var _logFilePathSelectFile :File = new File();
		
			
			//==========================================================
			//メソッド
			
			/**
			 * 初期化処理を行います。
			 * 
			 * @param event イベントオブジェクト(省略可能)
			 */
			private function onCreationComplete(event :Event = null) :void
			{
				//ウインドウを常に前面に表示するかどうかの設定をOFFにする
				this.alwaysInFront = false;
				
				//==========================================================
				//初期表示のための処理
				
				//設定情報用DTOの情報を元に画面の入力項目の値を設定
				setInputItemFromConfigDto(this.messengerManager.configDto);
				
				//グループのArrayCollectionをリフレッシュ
				refreshGroupArrayCollection();
				

				//==========================================================
				//ログファイルのパスを選択するためのファイルオブジェクトにイベントリスナーを設定
				this._logFilePathSelectFile.addEventListener(Event.SELECT, onLogFilePathSelectFileSelect);
				
				
				//==========================================================
				//バージョンアップ関連の処理
				
				//バージョン情報タブを最初に表示するかどうかのフラグがたっている場合
				if(this.isVersionTabFirstDisplay)
				{
					//バージョン情報タブを表示対象にする
					this.tabNavigator.selectedChild = this.versionInfoContainer;
				}

				//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
				//AIRのリモートアップデーターのイベントリスナーを設定する
				this.airRemoteUpdater.addEventListener(AIRRemoteUpdaterEvent.REMOTE_VERSION_CHECK, onAirRemoteUpdaterVersionCheck);
				this.airRemoteUpdater.addEventListener(IOErrorEvent.IO_ERROR, airRemoteUpdaterErrorHandler);
				this.airRemoteUpdater.addEventListener(SecurityErrorEvent.SECURITY_ERROR, airRemoteUpdaterErrorHandler);
				
				
				//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
				//AIRのリモートアップデーターから取得した読み取り専用プロパティをフィールドに設定
				this.localVersion = airRemoteUpdater.localVersion;
				this.copyright = airRemoteUpdater.localCopyRight;
				this.applicationName = airRemoteUpdater.localApplicationName;
				
				
				//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
				//自動バージョンアップ
				
				//この画面が最初に開かれた状態で、自動バージョンアップ処理を行う設定になっている場合
				if(isFirstOpen && this.messengerManager.configDto.isAutoVersionUp)
				{
					//バージョンチェックを行う
					versionCheck(true);
				}
				
				//==========================================================
				
				
				//この画面が最初に開かれた状態かどうかのフラグをfalseにする
				isFirstOpen = false;
				
				//グループ名の入力チェックを有効にする
				//(最初から入力チェックを行うと、入力チェックエラーがいつまでも残ってしまう場合があるのでできるだけタイミングを遅らせる)
				this.groupNameValidator.enabled = true;
			}
			
			/**
			 * 設定情報用DTOの情報を元に画面の入力項目の値を設定します。
			 * 
			 * @param configDto 設定情報用DTO
			 */
			private function setInputItemFromConfigDto(configDto :ConfigDto) :void
			{
				//==========================================================
				//各入力項目に値を設定
				
				//利用者名
				this.userNameInput.text = configDto.userName;
				
				//グループ名
				this.groupComboBox.text = configDto.groupName;
		
				//自動ログインを行うかどうかのフラグ
				this.autoLoginCheckBox.selected = configDto.isAutoLogin;
		
				//OS起動時にアプリケーションの自動起動を行うかどうかのフラグ
				this.autoStartCheckBox.selected = configDto.isAutoStart;
		
				//別のグループからの着信を拒否するかどうかのフラグ
				this.denyOtherGroupCheckBox.selected = configDto.isDenyOtherGroup;
		
				//ログをファイルに記録するかどうかのフラグ
				this.logCheckBox.selected = configDto.isLogging;
		
				//開封前の状態でログをファイルに記録するかどうかのフラグ
				this.beforeOpenLoggingCheckBox.selected = configDto.isBeforeOpenLogging;
		
				//ログファイルの絶対パス
				this.logFilePathInput.text = configDto.logFilePath;
				this.logFilePathInput.dispatchEvent(new FlexEvent(FlexEvent.VALUE_COMMIT));
		
				//着信メッセージをすぐにウインドウで表示するかどうかのフラグ
				this.receiveOpenWindowCheckBox.selected = configDto.isReceiveOpenWindow;
		
				//着信通知レベル
				SelectionUtil.selectRadioButton(this.receiveNotifyRadioGroup, configDto.receiveNotifyLevel, "value");
		
				//着信通知の通知ウインドウのタイトルの色
				this.receiveNotifyWindowTitleTextColorPicker.selectedColor = configDto.receiveNotifyWindowTitleTextColor;
				
				//着信通知の通知ウインドウのメッセージの色
				this.receiveNotifyWindowMessageTextColorPicker.selectedColor = configDto.receiveNotifyWindowMessageTextColor;
				
				//着信通知の通知ウインドウの背景の色
				this.receiveNotifyWindowBackgroundColorPicker.selectedColor = configDto.receiveNotifyWindowBackgroundColor;
				
				//着信通知表示時間
				this.receiveNotifyStepper.value = configDto.receiveNotifyDuration;
		
				//ログイン通知レベル
				SelectionUtil.selectRadioButton(this.loginNotifyRadioGroup, configDto.loginNotifyLevel, "value");
		
				//ログイン通知の通知ウインドウのタイトルの色
				this.loginNotifyWindowTitleTextColorPicker.selectedColor = configDto.loginNotifyWindowTitleTextColor;
				
				//ログイン通知の通知ウインドウのメッセージの色
				this.loginNotifyWindowMessageTextColorPicker.selectedColor = configDto.loginNotifyWindowMessageTextColor;
				
				//ログイン通知の通知ウインドウの背景の色
				this.loginNotifyWindowBackgroundColorPicker.selectedColor = configDto.loginNotifyWindowBackgroundColor;
				
				//ログイン通知表示時間
				this.loginNotifyStepper.value = configDto.loginNotifyDuration;
		
				//開封通知レベル
				SelectionUtil.selectRadioButton(this.openNotifyRadioGroup, configDto.openNotifyLevel, "value");
		
				//開封通知の通知ウインドウのタイトルの色
				this.openNotifyWindowTitleTextColorPicker.selectedColor = configDto.openNotifyWindowTitleTextColor;
				
				//開封通知の通知ウインドウのメッセージの色
				this.openNotifyWindowMessageTextColorPicker.selectedColor = configDto.openNotifyWindowMessageTextColor;
				
				//開封通知の通知ウインドウの背景の色
				this.openNotifyWindowBackgroundColorPicker.selectedColor = configDto.openNotifyWindowBackgroundColor;
				
				//開封通知表示時間
				this.openNotifyStepper.value = configDto.openNotifyDuration;
				
				//通知ウインドウクリック時の動作
				SelectionUtil.selectRadioButton(this.notifyWindowClickOperationRadioGroup, configDto.notifyWindowClickOperation, "value");
		
				//自分自身の色
				this.selfUserColorPicker.selectedColor = configDto.selfUserColor;
				
				//同じグループの色
				this.selfGroupColorPicker.selectedColor = configDto.selfGroupColor;
				
				//別のグループの色
				this.otherGroupColorPicker.selectedColor = configDto.otherGroupColor;
				
				//長時間音沙汰が無い人の表示を徐々に透明にしていくかどうかのフラグ
				this.idleDisplayTransparentCheckBox.selected = configDto.isIdleDisplayTransparent;
				
				//完全に音沙汰が無くなったとみなす時間
				this.idleDisplayMaxStepper.value = configDto.idleDisplayMaxDuration;
				
				//完全に音沙汰が無くなったときの透明度
				this.idleDisplayAlphaStepper.value = configDto.idleDisplayAlpha;
				
				//自動バージョンアップを行うかどうかのフラグ
				this.autoVersionUpCheckBox.selected = configDto.isAutoVersionUp;
		
				
				//==========================================================
				//各ラジオボタングループの値が変化した場合の処理も呼び出しておく
				receiveNotifyRadioGroupChangeHandler();
				loginNotifyRadioGroupChangeHandler();
				openNotifyRadioGroupChangeHandler();
			}
			
			/**
			 * 画面の入力項目の値を元に設定情報用DTOのインスタンスを作成して返します。
			 */
			private function createConfigDtoFromInputItem() :ConfigDto
			{
				//設定情報用DTOのインスタンスを生成
				var configDto :ConfigDto = new ConfigDto();
				
				//利用者名
				configDto.userName = this.userNameInput.text;
				
				//グループ名
				configDto.groupName = this.groupComboBox.text;
		
				//自動ログインを行うかどうかのフラグ
				configDto.isAutoLogin = this.autoLoginCheckBox.selected;
		
				//OS起動時にアプリケーションの自動起動を行うかどうかのフラグ
				configDto.isAutoStart = this.autoStartCheckBox.selected;
		
				//別のグループからの着信を拒否するかどうかのフラグ
				configDto.isDenyOtherGroup = this.denyOtherGroupCheckBox.selected;
		
				//ログをファイルに記録するかどうかのフラグ
				configDto.isLogging = this.logCheckBox.selected;
		
				//開封前の状態でログをファイルに記録するかどうかのフラグ
				configDto.isBeforeOpenLogging = this.beforeOpenLoggingCheckBox.selected;
		
				//ログファイルの絶対パス
				configDto.logFilePath = this.logFilePathInput.text;
		
				//着信メッセージをすぐにウインドウで表示するかどうかのフラグ
				configDto.isReceiveOpenWindow = this.receiveOpenWindowCheckBox.selected;
		
				//着信通知レベル
				configDto.receiveNotifyLevel = this.receiveNotifyRadioGroup.selectedValue as String;
		
				//着信通知の通知ウインドウのタイトルの色
				configDto.receiveNotifyWindowTitleTextColor = this.receiveNotifyWindowTitleTextColorPicker.selectedColor;
				
				//着信通知の通知ウインドウのメッセージの色
				configDto.receiveNotifyWindowMessageTextColor = this.receiveNotifyWindowMessageTextColorPicker.selectedColor;
				
				//着信通知の通知ウインドウの背景の色
				configDto.receiveNotifyWindowBackgroundColor = this.receiveNotifyWindowBackgroundColorPicker.selectedColor;
				
				//着信通知表示時間
				configDto.receiveNotifyDuration = this.receiveNotifyStepper.value;
		
				//ログイン通知レベル
				configDto.loginNotifyLevel = this.loginNotifyRadioGroup.selectedValue as String;
		
				//ログイン通知の通知ウインドウのタイトルの色
				configDto.loginNotifyWindowTitleTextColor = this.loginNotifyWindowTitleTextColorPicker.selectedColor;
				
				//ログイン通知の通知ウインドウのメッセージの色
				configDto.loginNotifyWindowMessageTextColor = this.loginNotifyWindowMessageTextColorPicker.selectedColor;
				
				//ログイン通知の通知ウインドウの背景の色
				configDto.loginNotifyWindowBackgroundColor = this.loginNotifyWindowBackgroundColorPicker.selectedColor;
				
				//ログイン通知表示時間
				configDto.loginNotifyDuration = this.loginNotifyStepper.value;
		
				//開封通知レベル
				configDto.openNotifyLevel = this.openNotifyRadioGroup.selectedValue as String;
		
				//開封通知の通知ウインドウのタイトルの色
				configDto.openNotifyWindowTitleTextColor = this.openNotifyWindowTitleTextColorPicker.selectedColor;
				
				//開封通知の通知ウインドウのメッセージの色
				configDto.openNotifyWindowMessageTextColor = this.openNotifyWindowMessageTextColorPicker.selectedColor;
				
				//開封通知の通知ウインドウの背景の色
				configDto.openNotifyWindowBackgroundColor = this.openNotifyWindowBackgroundColorPicker.selectedColor;
				
				//開封通知表示時間
				configDto.openNotifyDuration = this.openNotifyStepper.value;
				
				//通知ウインドウクリック時の動作
				configDto.notifyWindowClickOperation = this.notifyWindowClickOperationRadioGroup.selectedValue as String;
		
				//自分自身の色
				configDto.selfUserColor = this.selfUserColorPicker.selectedColor;
				
				//同じグループの色
				configDto.selfGroupColor = this.selfGroupColorPicker.selectedColor;
				
				//別のグループの色
				configDto.otherGroupColor = this.otherGroupColorPicker.selectedColor;
				
				//長時間音沙汰が無い人の表示を徐々に透明にしていくかどうかのフラグ
				configDto.isIdleDisplayTransparent = this.idleDisplayTransparentCheckBox.selected;
				
				//完全に音沙汰が無くなったとみなす時間
				configDto.idleDisplayMaxDuration = this.idleDisplayMaxStepper.value;
				
				//完全に音沙汰が無くなったときの透明度
				configDto.idleDisplayAlpha = this.idleDisplayAlphaStepper.value;

				//自動バージョンアップを行うかどうかのフラグ
				configDto.isAutoVersionUp = this.autoVersionUpCheckBox.selected;

		
				//作成した設定情報用DTOを返す
				return configDto;
			}
			
			/**
			 * グループのArrayCollectionをリフレッシュします。
			 */
			private function refreshGroupArrayCollection() :void
			{
				//ログイン中の全ての利用者のグループ名の配列を取得
				var loginGroupNameList :Array = this.messengerManager.loginGroupNameList;
				
				//==========================================================
				//自分自身のグループ名が配列の最初にくるようにする
				
				//自分自身のグループ名として、グループ名のコンボボックスに入力されている内容を取得
				var groupName :String = this.groupComboBox.text;
				
				//ログイン中の全ての利用者のグループ名の配列から自分自身のグループ名を削除
				ArrayUtil.removeAllObject(loginGroupNameList, groupName);
				
				//ログイン中の全ての利用者のグループ名の配列の最初に自分自身のグループ名を追加
				ArrayUtil.add(loginGroupNameList, 0, groupName);
				//==========================================================
				
				//取得した配列をグループのArrayCollectionに関連づける
				this.groupArrayCollection.source = loginGroupNameList;
			}
			
			/**
			 * 着信通知に関するラジオボタングループの値が変化した場合のイベント処理を行います。
			 * 
			 * @param event イベントオブジェクト(省略可能)
			 */
			private function receiveNotifyRadioGroupChangeHandler(event :Event = null) :void
			{
				//「通知レベル: 行わない」の選択肢が選択された場合
				if(this.receiveNotifyRadioGroup.selectedValue == ForesMessengerConstant.NOTIFY_LEVEL_NONE)
				{
					//着信通知を行うかどうかのフラグをOFFにする
					this.receiveNotifyEnable = false;
				}
				//それ以外の場合
				else
				{
					//着信通知を行うかどうかのフラグをONにする
					this.receiveNotifyEnable = true;
				}
			}

			/**
			 * ログイン通知に関するラジオボタングループの値が変化した場合のイベント処理を行います。
			 * 
			 * @param event イベントオブジェクト(省略可能)
			 */
			private function loginNotifyRadioGroupChangeHandler(event :Event = null) :void
			{
				//「通知レベル: 行わない」の選択肢が選択された場合
				if(this.loginNotifyRadioGroup.selectedValue == ForesMessengerConstant.NOTIFY_LEVEL_NONE)
				{
					//ログイン通知を行うかどうかのフラグをOFFにする
					this.loginNotifyEnable = false;
				}
				//それ以外の場合
				else
				{
					//ログイン通知を行うかどうかのフラグをONにする
					this.loginNotifyEnable = true;
				}
			}

			/**
			 * 開封通知に関するラジオボタングループの値が変化した場合のイベント処理を行います。
			 * 
			 * @param event イベントオブジェクト(省略可能)
			 */
			private function openNotifyRadioGroupChangeHandler(event :Event = null) :void
			{
				//「開封通知レベル: 画面右下の通知ウインドウで通知する」以外の選択肢が選択された場合
				if(this.openNotifyRadioGroup.selectedValue != ForesMessengerConstant.OPEN_NOTIFY_LEVEL_NOTIFY)
				{
					//開封通知を行うかどうかのフラグをOFFにする
					this.openNotifyEnable = false;
				}
				//それ以外の場合
				else
				{
					//開封通知を行うかどうかのフラグをONにする
					this.openNotifyEnable = true;
				}
			}

			/**
			 * ウインドウのドラッグ移動を開始します。
			 */
			private function startWindowDrag():void 
			{
				//ウインドウのドラッグ移動を開始する
				//(マウスを放せば勝手に移動モードが解除されるので、開始処理だけで良い)
				this.stage.nativeWindow.startMove();
			}

			/**
			 * マウスイベントに応じて右上の閉じるボタンの画像を切り替えます。
			 * 
			 * @param event イベントオブジェクト
			 */
			private function swapCloseButtonImage(event: MouseEvent) :void 
			{
				//マウスオーバーイベントの場合
				if (event.type == MouseEvent.MOUSE_OVER) 
				{
					//マウスオーバー用の画像に切り替える
					closebutton.source = ForesMessengerIconConstant.close_over_image;
				} 
				//それ以外の場合
				else 
				{
					//通常時の画像に切り替える
					closebutton.source = ForesMessengerIconConstant.close_image;
				}
			}

			/**
			 * OKボタンが押された場合のイベント処理を行います。
			 * 
			 * @param event イベントオブジェクト
			 */
			private function onOkButtonClick(event :Event = null) :void
			{
				//入力チェックエラーがある場合
				if(Validator.validateAll(validatorArray).length != 0)
				{
					//エラーメッセージを表示
					Alert.show("入力エラーがあります。", "入力エラー", Alert.OK, this);
					
					//以降の処理を行わない
					return;
				}
				
				//画面の入力項目の値を元に設定情報用DTOのインスタンスを作成して、メッセンジャーのメインの管理クラスに設定
				this.messengerManager.configDto = createConfigDtoFromInputItem();
				
				//ログイン中の場合
				if(this.messengerManager.isLogin)
				{
					//自分自身のウインドウを閉じる
					this.close();
				}
				//それ以外の場合
				else
				{
					//ログイン処理を実行中かどうかのフラグをたてる
					this.isLoginPlaying = true;
					
					//ログイン処理を行う
					this.messengerManager.login();

					//自分自身のウインドウを閉じる
					this.close();
				}
			}
			
			/**
			 * 閉じるボタン、またはキャンセルボタンが押された場合のイベント処理を行います。
			 * 
			 * @param event イベントオブジェクト
			 */
			private function onCloseButtonClick(event :Event = null) :void
			{
				//ログイン中の場合
				if(this.messengerManager.isLogin)
				{
					//自分自身のウインドウを閉じる
					this.close();
				}
				//それ以外の場合
				else
				{
					//アプリケーションを正常終了させる
					this.messengerManager.safetyExitApplication(0);
				}
			}

			/**
			 * バージョンチェックボタンが押された場合のイベント処理を行います。
			 */
			private function onClickVersionCheck() :void
			{
				//バージョンチェックを行う
				versionCheck();
			}
			
			/**
			 * バージョンチェックを行います。
			 * 
			 * @param isStartVersionCheck 起動時のバージョンチェックかどうかのフラグ
			 */
			private function versionCheck(isStartVersionCheck :Boolean = false) :void
			{
				//起動時のバージョンチェックかどうかのフラグをフィールドに設定
				this.isStartVersionCheck = isStartVersionCheck;
				
				//リモートアップデーターのリモートバージョンチェック処理を呼び出す
				this.airRemoteUpdater.remoteVersionCheck(AIR_URL);
			}

			/**
			 * リモートアップデーターのバージョンチェックが完了した場合のイベント処理を行います。
			 * 
			 * @param event イベントオブジェクト
			 */
			private function onAirRemoteUpdaterVersionCheck(event :Event) :void
			{
				//リモートアップデーターのローカルバージョンとリモートバージョンが一致する場合
				if(this.airRemoteUpdater.localVersion == this.airRemoteUpdater.remoteVersion)
				{
					//起動時のバージョンチェックでない場合
					if(!this.isStartVersionCheck)
					{
						//メッセージを表示
						Alert.show("すでに最新のバージョンがインストールされています。", "最新バージョン", Alert.OK, this);
					}
					
					//自動ログインで自動バージョンチェックの場合
					if(this.isAutoLoginVersionCheck)
					{
						//自分自身のウインドウを閉じる
						this.close();
					}
				}
				//それ以外の場合
				else
				{
					//自動ログインで自動バージョンチェックの場合
					if(this.isAutoLoginVersionCheck)
					{
						//自分自身のウインドウが表示されるようにする
						this.visible = true;
					}
					
					//確認ダイアログを表示
					Alert.show("新しいバージョン:" + this.airRemoteUpdater.remoteVersion + " が公開されています。\nアップデートしますか？", "アップデート確認", Alert.YES | Alert.NO, this, updateAlertClickHandler);
				}
			}

			/**
			 * リモートアップデーターでエラーが発生した場合のイベント処理を行います。
			 * 
			 * @param event イベントオブジェクト
			 */
			private function airRemoteUpdaterErrorHandler(event :Event) :void
			{
				//メッセージを表示
				Alert.show("通信エラーが発生しました。", "エラー", Alert.OK, this);
			}

			/**
			 * アップデートの確認ダイアログが押された場合のイベント処理を行います。
			 * 
			 * @param event イベントオブジェクト
			 */
			private function updateAlertClickHandler(event :CloseEvent) :void 
			{
				//「はい」が押された場合
				if (event.detail == Alert.YES)
				{
					//バージョンアップ時のログアウト処理を行う
					this.messengerManager.logoutForVersionUp();
					
					//アップデート実行
					this.airRemoteUpdater.update(AIR_URL, this.airRemoteUpdater.remoteVersion);
				}
				//それ以外の場合
				else
				{
					//自動ログインで自動バージョンチェックの場合
					if(this.isAutoLoginVersionCheck)
					{
						//自分自身のウインドウを閉じる
						this.close();
					}
				}
			}
			
			/**
			 * ウインドウが閉じられる場合の処理を行います。
			 * 
			 * @param event イベントオブジェクト
			 */
			private function onClosing(event :Event) :void
			{
				//ログイン中の場合、またはログイン処理を実行中、または自動ログインで自動バージョンチェックの場合
				if(this.messengerManager.isLogin || this.isLoginPlaying || this.isAutoLoginVersionCheck)
				{
					//==========================================================
					//普通にウインドウを閉じただけだとメモリがどんどん喰われていくので、ガベージコレクションがされるように工夫する
					//(なぜかウインドウを最小化した場合のみ、ガベージコレクションされる)
					//(System.gc()ではまったく効果がない)
					
					//Windowsの場合
					//(Macの場合は見た目が悪くなりすぎるので行わない)
					if(TrayIconUtil.isWindows())
					{
						//自分自身を見えなくする
						this.visible = false;
						
						//自分自身のウインドウを最小化する
						this.minimize();
					}

					//以降の処理を行わない
					return;
				}
				
				//デフォルトのイベント処理を行わないようにする
				event.preventDefault();
				
				//アプリケーションを正常終了させる
				this.messengerManager.safetyExitApplication(0);
			}
			
			/**
			 * 基本設定タブが表示された場合のイベント処理を行います。
			 * 
			 * @param event イベントオブジェクト
			 */
			private function onBasicConfigContainerShow(event :Event = null) :void
			{
				//グループのArrayCollectionをリフレッシュ
				refreshGroupArrayCollection();
			}
			
			/**
			 * ログファイルパス選択ボタンがクリックされた場合のイベント処理を行います。
			 * 
			 * @param event イベントオブジェクト
			 */
			private function onLogFilePathSelectButtonClick(event :Event = null) :void
			{
				//ログファイルのパスのテキストフィールドが入力されている場合
				if(!StringUtil.isBlank(this.logFilePathInput.text))
				{
					try
					{
						//ログファイルのパスを選択するためのファイルオブジェクトのネイティブパスに、ログファイルのパスのテキストフィールドりテキストの値を設定
						this._logFilePathSelectFile.nativePath = this.logFilePathInput.text;
					}
					//例外処理
					//(不正なパスをネイティブパスに指定しようとするとエラーが発生してしまうため)
					catch(e :Error)
					{
						//ログファイルのパスを選択するためのファイルオブジェクトのネイティブパスに、アプリケーションのプライベート記憶領域ディレクトリのネイティブパスを設定
						this._logFilePathSelectFile.nativePath = File.applicationStorageDirectory.nativePath;
					}
				}
				//それ以外の場合
				else
				{
					//ログファイルのパスを選択するためのファイルオブジェクトのネイティブパスに、アプリケーションのプライベート記憶領域ディレクトリのネイティブパスを設定
					this._logFilePathSelectFile.nativePath = File.applicationStorageDirectory.nativePath;
				}
				
				try
				{
					//保存先のファイル選択ダイアログを開く
					this._logFilePathSelectFile.browseForSave("ログファイルのパスを選択して下さい");
				}
				//例外処理
				//(ファイル選択ダイアログを同時に複数開こうとする例外が発生してしまうため)
				catch(e :Error)
				{
					//特に何も行わない
				}
			}
			
			/**
			 * ログファイルのパスを選択するためのダイアログでファイルが選択された場合のイベント処理を行います。
			 * 
			 * @param event イベントオブジェクト
			 */
			private function onLogFilePathSelectFileSelect(event :Event = null) :void
			{
				//ログファイルのパスのテキストフィールドのテキストに選択されたファイルのネイティブパスを設定
				this.logFilePathInput.text = this._logFilePathSelectFile.nativePath;
				
				//入力チェックのためvalueCommitイベントを投げる
				this.logFilePathInput.dispatchEvent(new FlexEvent(FlexEvent.VALUE_COMMIT));
			}
			
			/**
			 * 指定された秒数だけ通知ウインドウをプレビュー表示します。
			 * 
			 * @param second 秒数
			 * @param titleTextColor 通知ウインドウのタイトルのテキストの色
			 * @param messageTextColor 通知ウインドウのメッセージのテキストの色
			 * @param backgroundColor 通知ウインドウの背景の色
			 */
			private function previewNotify(second :uint, titleTextColor :uint, messageTextColor :uint, backgroundColor :uint) :void
			{
				//通知タイトル
				var notifyTitle :String = "通知メッセージのプレビュー";
				
				//通知メッセージ
				var notifyMessage :String = second + "秒間の通知はこのように表示されます。\n(クリックすると閉じます)";
				
				//通知ウインドウにメッセージを表示
				this.messengerManager.addNotification(notifyTitle, notifyMessage, second, titleTextColor, messageTextColor, backgroundColor);
			}
			
			/**
			 * 全てのValidatorをリフレッシュします。
			 */
			private function refreshForAllValidator() :void
			{
				//全てのValidatorに対して処理を行う
				for each(var validator :Validator in this.validatorArray)
				{
					//Validatorが有効な場合
					if(validator.enabled)
					{
						//バリデートチェックを行う
						validator.validate();
					}
					//Validatorが無効な場合
					else
					{
						//バリデート成功のイベントを投げる
						//(この処理を行わないと、エラー状態のまま無効になるとずっとエラーメッセージが表示されてしまうので注意)
						validator.dispatchEvent(new ValidationResultEvent(ValidationResultEvent.VALID));
					}
				}
			}
			
		]]>
	</mx:Script>

	<!-- 複数のValidatorを束ねるための配列 -->
	<mx:Array id="validatorArray">
		<!-- 名前の必須チェック -->
		<mx:Validator source="{this.userNameInput}" 
			property="text" 
			required="true" 
			requiredFieldError="名前を入力して下さい"
			/>
		
		<!-- グループ名の必須チェックと文字数チェック(20文字以内) -->
		<mx:StringValidator id="groupNameValidator" source="{this.groupComboBox}" 
			property="text" 
			required="true" 
			requiredFieldError="グループ名を入力して下さい"
			maxLength="20" 
			tooLongError="グループ名は20文字以内で入力して下さい"
			enabled="false"
			/>

		<!-- ログファイルのパスのチェックにファイルパス専用のカスタムバリデーターを指定 -->
		<!-- (送受信した内容をログに記録するかどうかのフラグに応じて有効・無効が変化する) -->
		<!-- (ファイルのみ許可してディレクトリは不許可にするが、存在しないファイルは許可する) -->
		<validators:FileValidator source="{this.logFilePathInput}" 
			property="text" 
			enabled="{this.logCheckBox.selected}"
			required="true" 
			requiredFieldError="ログファイルのパスを入力して下さい"
			isOnlyFile="true"
			isOnlyExistFile="false"
			/>
		
	</mx:Array>


	<mx:Image id="background" source="{ForesMessengerIconConstant.background_config_image}" x="0" y="0" mouseDown="startWindowDrag()"/>
	<mx:Image id="closebutton" toolTip="閉じる" source="{ForesMessengerIconConstant.close_image}" mouseChildren="false" buttonMode="true" useHandCursor="true" click="onCloseButtonClick()" mouseOut="swapCloseButtonImage(event)" mouseOver="swapCloseButtonImage(event)" y="7" x="470"/>

	<mx:VBox width="100%" height="100%" y="33">
		<!-- 各設定画面をタブで切り替えられるようにする -->
		<mx:TabNavigator id="tabNavigator"
			width="100%" height="324"
			creationPolicy="all"
			paddingTop="0"
			verticalGap="0"
			>
			
			<!-- 基本設定タブ -->
			<mx:VBox id="basicConfigContainer"
				width="100%" height="100%"
				label="基本設定"
				paddingLeft="10"
				paddingTop="10"
				show="onBasicConfigContainerShow()"
				>
				<mx:HBox width="100%">
					<mx:Label text="名前:" width="{this.groupLabel.width}" selectable="true" />
					<mx:TextInput id="userNameInput" 
						width="200" 
						maxChars="20" 
						/>
					<mx:Label text="(最大20文字)" selectable="true" />
				</mx:HBox>
	
				<mx:HBox width="100%">
					<mx:Label id="groupLabel" text="グループ名:" selectable="true" />
					<mx:ComboBox id="groupComboBox" 
						width="200"
						dataProvider="{this.groupArrayCollection}" 
						editable="true"
						/>
					<mx:Label text="(最大20文字)" selectable="true" />
				</mx:HBox>
	
				<mx:Spacer height="30" />
	
				<mx:CheckBox id="autoLoginCheckBox" 
					label="起動時に自動的にログインする" 
					keyDown="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" keyUp="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" 
					/>
				<mx:CheckBox id="autoStartCheckBox" 
					label="OS起動時にアプリケーションを自動起動する" 
					keyDown="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" keyUp="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" 
					/>
				<mx:CheckBox id="denyOtherGroupCheckBox" 
					label="別のグループからの着信を拒否する" 
					keyDown="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" keyUp="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" 
					/>
			</mx:VBox>
	
			<!-- ログ設定タブ -->
			<mx:VBox id="logConfigContainer"
				width="100%" height="100%"
				label="ログ設定"
				paddingLeft="10"
				paddingRight="10"
				paddingTop="10"
				>
				
				<mx:HBox width="100%">
					<!-- 値の変更後に全てのValidatorをリフレッシュする処理を呼び出す -->
					<!-- (callLater付きで呼び出しているのは、そのままでは値の変更処理が反映される前にValidatorをリフレッシュする処理が呼び出されてしまい、ワンテンポずれてしまうため)  -->
					<mx:CheckBox id="logCheckBox"
						label="送受信した内容をログに記録する" 
						change="callLater(refreshForAllValidator)"
						keyDown="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" keyUp="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)"  
						/>
				</mx:HBox>
	
				<mx:VBox width="100%" enabled="{this.logCheckBox.selected}">
					<mx:HBox width="100%">
						<mx:CheckBox id="beforeOpenLoggingCheckBox"
							label="開封前の状態でログをファイルに記録する" 
							keyDown="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" keyUp="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" 
							/>
					</mx:HBox>
		
					<mx:HBox width="100%">
						<mx:Label text="ログファイルのパス:" selectable="true" />
						<mx:TextInput id="logFilePathInput" width="100%" />
						<mx:Button label="ファイル選択" 
							click="onLogFilePathSelectButtonClick()" 
							keyDown="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" keyUp="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" 
							/>
					</mx:HBox>
				</mx:VBox>
			</mx:VBox>
	
			<!-- 通知設定タブ -->
			<mx:VBox id="notifyConfigContainer"
				width="100%" height="100%"
				label="通知設定"
				verticalGap="0"
				>

				<!-- アコーディオンで複数のコンテナを表示する -->
				<mx:Accordion width="100%" height="100%" creationPolicy="all">

					<!-- 着信通知設定コンテナ -->
					<mx:VBox id="receiveNotifyConfigContainer"
						width="100%" height="100%"
						label="着信通知設定"
						paddingLeft="10"
						>
						
						<mx:HBox width="100%">
							<mx:CheckBox id="receiveOpenWindowCheckBox" 
								label="着信メッセージをすぐにポップアップウインドウで表示する" 
								keyDown="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" keyUp="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" 
								/>
						</mx:HBox>

						<mx:HBox width="100%">
							<mx:RadioButtonGroup id="receiveNotifyRadioGroup" change="receiveNotifyRadioGroupChangeHandler()" />
							<mx:RadioButton group="{this.receiveNotifyRadioGroup}"
								label="全ての着信に対して行う" 
								value="{ForesMessengerConstant.NOTIFY_LEVEL_ALL}" 
								/>
							<mx:RadioButton group="{this.receiveNotifyRadioGroup}"
								label="同じグループからの着信に対して行う" 
								value="{ForesMessengerConstant.NOTIFY_LEVEL_GROUP}" 
								/>
							<mx:RadioButton group="{this.receiveNotifyRadioGroup}"
								label="行わない" 
								value="{ForesMessengerConstant.NOTIFY_LEVEL_NONE}" 
								/>
						</mx:HBox>

						<mx:VBox width="100%" enabled="{this.receiveNotifyEnable}">
							<mx:HBox width="100%" verticalAlign="middle">
								<mx:Label text="通知ウインドウのタイトルの色:" width="{this.receiveNotifyWindowMessageTextColorLabel.width}" selectable="true" />
								<mx:ColorPicker id="receiveNotifyWindowTitleTextColorPicker" showTextField="true" />
							</mx:HBox>
							
							<mx:HBox width="100%" verticalAlign="middle">
								<mx:Label id="receiveNotifyWindowMessageTextColorLabel" text="通知ウインドウのメッセージの色:" selectable="true" />
								<mx:ColorPicker id="receiveNotifyWindowMessageTextColorPicker" showTextField="true" />
							</mx:HBox>
							
							<mx:HBox width="100%" verticalAlign="middle">
								<mx:Label text="通知ウインドウの背景の色:" width="{this.receiveNotifyWindowMessageTextColorLabel.width}" selectable="true" />
								<mx:ColorPicker id="receiveNotifyWindowBackgroundColorPicker" showTextField="true" />
							</mx:HBox>
							
							<mx:HBox width="100%" verticalAlign="middle">
								<mx:Label text="通知ウインドウの表示時間(単位=秒):" selectable="true" />
								<mx:NumericStepper id="receiveNotifyStepper"
									value="3"
									minimum="1"
									maximum="9999"
									stepSize="1"
									/>
									
								<mx:Spacer width="20" />
								<mx:Button label="プレビュー" 
									click="previewNotify(this.receiveNotifyStepper.value, this.receiveNotifyWindowTitleTextColorPicker.selectedColor, this.receiveNotifyWindowMessageTextColorPicker.selectedColor, this.receiveNotifyWindowBackgroundColorPicker.selectedColor)" 
									keyDown="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" keyUp="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" 
									/>
							</mx:HBox>
						</mx:VBox>
					</mx:VBox>
						
					<!-- ログイン通知設定コンテナ -->
					<mx:VBox id="loginNotifyConfigContainer"
						width="100%" height="100%"
						label="ログイン通知設定"
						paddingLeft="10"
						>
						
						<mx:HBox width="100%">
							<mx:RadioButtonGroup id="loginNotifyRadioGroup" change="loginNotifyRadioGroupChangeHandler()" />
							<mx:RadioButton group="{this.loginNotifyRadioGroup}"
								label="全てのメンバーに対して行う" 
								value="{ForesMessengerConstant.NOTIFY_LEVEL_ALL}" 
								/>
							<mx:RadioButton group="{this.loginNotifyRadioGroup}"
								label="同じグループのメンバーに対して行う" 
								value="{ForesMessengerConstant.NOTIFY_LEVEL_GROUP}" 
								/>
							<mx:RadioButton group="{this.loginNotifyRadioGroup}"
								label="行わない" 
								value="{ForesMessengerConstant.NOTIFY_LEVEL_NONE}" 
								/>
						</mx:HBox>

						<mx:VBox width="100%" enabled="{this.loginNotifyEnable}">
							<mx:HBox width="100%" verticalAlign="middle">
								<mx:Label text="通知ウインドウのタイトルの色:" width="{this.loginNotifyWindowMessageTextColorLabel.width}" selectable="true" />
								<mx:ColorPicker id="loginNotifyWindowTitleTextColorPicker" showTextField="true" />
							</mx:HBox>
							
							<mx:HBox width="100%" verticalAlign="middle">
								<mx:Label id="loginNotifyWindowMessageTextColorLabel" text="通知ウインドウのメッセージの色:" selectable="true" />
								<mx:ColorPicker id="loginNotifyWindowMessageTextColorPicker" showTextField="true" />
							</mx:HBox>
							
							<mx:HBox width="100%" verticalAlign="middle">
								<mx:Label text="通知ウインドウの背景の色:" width="{this.loginNotifyWindowMessageTextColorLabel.width}" selectable="true" />
								<mx:ColorPicker id="loginNotifyWindowBackgroundColorPicker" showTextField="true" />
							</mx:HBox>
							
							<mx:HBox width="100%" verticalAlign="middle">
								<mx:Label text="通知ウインドウの表示時間(単位=秒):" selectable="true" />
								<mx:NumericStepper id="loginNotifyStepper"
									value="3"
									minimum="1"
									maximum="9999"
									stepSize="1"
									/>
									
								<mx:Spacer width="20" />
								<mx:Button label="プレビュー" 
									click="previewNotify(this.loginNotifyStepper.value, this.loginNotifyWindowTitleTextColorPicker.selectedColor, this.loginNotifyWindowMessageTextColorPicker.selectedColor, this.loginNotifyWindowBackgroundColorPicker.selectedColor)" 
									keyDown="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" keyUp="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" 
									/>
							</mx:HBox>
						</mx:VBox>
					</mx:VBox>

					<!-- 開封通知設定コンテナ -->
					<mx:VBox id="openNotifyConfigContainer"
						width="100%" height="100%"
						label="開封通知設定"
						paddingLeft="10"
						>
						
						<mx:HBox width="100%">
							<mx:RadioButtonGroup id="openNotifyRadioGroup" change="openNotifyRadioGroupChangeHandler()" />
							<mx:RadioButton group="{this.openNotifyRadioGroup}"
								label="画面右下の通知ウインドウで通知する" 
								value="{ForesMessengerConstant.OPEN_NOTIFY_LEVEL_NOTIFY}" 
								/>
							<mx:RadioButton group="{this.openNotifyRadioGroup}"
								label="ポップアップウインドウで通知する" 
								value="{ForesMessengerConstant.OPEN_NOTIFY_LEVEL_WINDOW}" 
								/>
							<mx:RadioButton group="{this.openNotifyRadioGroup}"
								label="行わない" 
								value="{ForesMessengerConstant.OPEN_NOTIFY_LEVEL_NONE}" 
								/>
						</mx:HBox>

						<mx:VBox width="100%" enabled="{this.openNotifyEnable}">
							<mx:HBox width="100%" verticalAlign="middle">
								<mx:Label text="通知ウインドウのタイトルの色:" width="{this.openNotifyWindowMessageTextColorLabel.width}" selectable="true" />
								<mx:ColorPicker id="openNotifyWindowTitleTextColorPicker" showTextField="true" />
							</mx:HBox>
							
							<mx:HBox width="100%" verticalAlign="middle">
								<mx:Label id="openNotifyWindowMessageTextColorLabel" text="通知ウインドウのメッセージの色:" selectable="true" />
								<mx:ColorPicker id="openNotifyWindowMessageTextColorPicker" showTextField="true" />
							</mx:HBox>
							
							<mx:HBox width="100%" verticalAlign="middle">
								<mx:Label text="通知ウインドウの背景の色:" width="{this.openNotifyWindowMessageTextColorLabel.width}" selectable="true" />
								<mx:ColorPicker id="openNotifyWindowBackgroundColorPicker" showTextField="true" />
							</mx:HBox>
							
							<mx:HBox width="100%" verticalAlign="middle">
								<mx:Label text="通知ウインドウの表示時間(単位=秒):" selectable="true" />
								<mx:NumericStepper id="openNotifyStepper"
									value="3"
									minimum="1"
									maximum="9999"
									stepSize="1"
									/>
									
								<mx:Spacer width="20" />
								<mx:Button label="プレビュー" 
									click="previewNotify(this.openNotifyStepper.value, this.openNotifyWindowTitleTextColorPicker.selectedColor, this.openNotifyWindowMessageTextColorPicker.selectedColor, this.openNotifyWindowBackgroundColorPicker.selectedColor)" 
									keyDown="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" keyUp="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" 
									/>
							</mx:HBox>
						</mx:VBox>
					</mx:VBox>

					<!-- 通知ウインドウクリック時の設定コンテナ -->
					<mx:VBox id="notifyWindowClickConfigContainer"
						width="100%" height="100%"
						label="通知ウインドウクリック時の設定"
						paddingLeft="10"
						>
						
						<mx:HBox width="100%">
							<mx:RadioButtonGroup id="notifyWindowClickOperationRadioGroup" />
							<mx:RadioButton group="{this.notifyWindowClickOperationRadioGroup}"
								label="全ての通知をまとめて閉じる" 
								value="{ForesMessengerConstant.NOTIFY_WINDOW_CLICK_OPERATION_ALL_CLOSE}" 
								/>
							<mx:RadioButton group="{this.notifyWindowClickOperationRadioGroup}"
								label="次の通知を表示する" 
								value="{ForesMessengerConstant.NOTIFY_WINDOW_CLICK_OPERATION_NEXT}" 
								/>
						</mx:HBox>

					</mx:VBox>
						
				</mx:Accordion>
			</mx:VBox>

			<!-- 表示設定タブ -->
			<mx:VBox id="displayConfigContainer"
				width="100%" height="100%"
				label="表示設定"
				verticalGap="0"
				>
				
				<!-- アコーディオンで複数のコンテナを表示する -->
				<mx:Accordion width="100%" height="100%" creationPolicy="all">
					
					<!-- 色設定コンテナ -->
					<mx:VBox id="colorConfigContainer"
						width="100%" height="100%"
						label="色設定"
						paddingLeft="10"
						>
						
						<mx:HBox width="100%" verticalAlign="middle">
							<mx:Label text="自分自身の色:" width="{this.otherGroupColorLabel.width}" selectable="true" />
							<mx:ColorPicker id="selfUserColorPicker" showTextField="true" />
							
							<mx:Spacer width="20" />
							<mx:HBox backgroundColor="0xFFFFFF" paddingLeft="10" paddingRight="10">
								<mx:Label text="表示サンプル" color="{this.selfUserColorPicker.selectedColor}" />
							</mx:HBox>
						</mx:HBox>
						
						<mx:HBox width="100%" verticalAlign="middle">
							<mx:Label text="同じグループの色:" width="{this.otherGroupColorLabel.width}" selectable="true" />
							<mx:ColorPicker id="selfGroupColorPicker" showTextField="true" />
							
							<mx:Spacer width="20" />
							<mx:HBox backgroundColor="0xFFFFFF" paddingLeft="10" paddingRight="10">
								<mx:Label text="表示サンプル" color="{this.selfGroupColorPicker.selectedColor}" />
							</mx:HBox>
						</mx:HBox>
						
						<mx:HBox width="100%" verticalAlign="middle">
							<mx:Label id="otherGroupColorLabel" text="別のグループの色:" selectable="true" />
							<mx:ColorPicker id="otherGroupColorPicker" showTextField="true" />
							
							<mx:Spacer width="20" />
							<mx:HBox backgroundColor="0xFFFFFF" paddingLeft="10" paddingRight="10">
								<mx:Label text="表示サンプル" color="{this.otherGroupColorPicker.selectedColor}" />
							</mx:HBox>
						</mx:HBox>
						
					</mx:VBox>

					<!-- 長時間音沙汰が無い人の表示設定コンテナ -->
					<mx:VBox id="idleDisplayConfigContainer"
						width="100%" height="100%"
						label="長時間音沙汰が無い人の表示設定"
						paddingLeft="10"
						>
						
						<mx:HBox width="100%">
							<mx:CheckBox id="idleDisplayTransparentCheckBox"
								label="長時間音沙汰が無い人の表示を徐々に透明にしていく" 
								keyDown="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" keyUp="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" 
								/>
						</mx:HBox>
						
						<mx:VBox width="100%" enabled="{this.idleDisplayTransparentCheckBox.selected}">
							<mx:HBox width="100%" verticalAlign="middle">
								<mx:Label text="完全に音沙汰が無くなったとみなす時間(単位=分, 5分以上):" selectable="true" />
								<mx:NumericStepper id="idleDisplayMaxStepper"
									value="60"
									minimum="5"
									maximum="999"
									stepSize="1"
									/>
							</mx:HBox>
	
							<mx:HBox width="100%" verticalAlign="middle">
								<mx:Label text="完全に音沙汰が無くなったときの透明度(アルファ値):" selectable="true" />
								<mx:NumericStepper id="idleDisplayAlphaStepper"
									value="0.3"
									minimum="0.1"
									maximum="0.9"
									stepSize="0.1"
									/>
									
								<mx:Spacer width="20" />
								<mx:HBox backgroundColor="0xFFFFFF" paddingLeft="10" paddingRight="10">
									<mx:Label text="表示サンプル" color="0x000000" alpha="{this.idleDisplayAlphaStepper.value}" />
								</mx:HBox>
							</mx:HBox>
						</mx:VBox>
						
					</mx:VBox>
				</mx:Accordion>
			</mx:VBox>


			<!-- バージョン情報タブ -->
			<mx:VBox id="versionInfoContainer"
				width="100%" height="100%"
				label="バージョン情報"
				horizontalAlign="center"
				horizontalScrollPolicy="off" verticalScrollPolicy="off"
				paddingTop="10"
				>
				
				<mx:VBox width="100%" height="30%"  horizontalScrollPolicy="off" verticalScrollPolicy="off">
					<!-- ロゴとアプリケーション名 -->
					<mx:HBox width="100%" horizontalAlign="center" verticalAlign="middle">
						<mx:Image source="icons/icon_128.png" width="36" height="36" />
						<mx:Label text="{this.applicationName}" fontSize="24" selectable="true" />
					</mx:HBox>
			
					<!-- コピーライト -->
					<mx:HBox width="100%" horizontalAlign="center">
						<mx:Label text="Copyright: {this.copyright}" selectable="true" />
					</mx:HBox>
			
					<!-- ローカルバージョン -->
					<mx:HBox width="100%" horizontalAlign="center">
						<mx:Label text="Version: {this.localVersion}" selectable="true" />
					</mx:HBox>
			
					<!-- 位置あわせのスペーサー -->
					<mx:Spacer height="5" />
			
					<!-- バージョンチェックボタン -->
					<mx:HBox width="100%" horizontalAlign="center">
						<mx:Button label="新しいバージョンのチェック" 
							click="onClickVersionCheck()"
							keyDown="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" keyUp="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" 
							/>
					</mx:HBox>

					<!-- 自動バージョンチェックのチェックボックス -->
					<mx:HBox width="100%" horizontalAlign="center">
						<mx:CheckBox id="autoVersionUpCheckBox" 
							label="自動的にバージョンチェックを行う" 
							keyDown="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" keyUp="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" 
							/>
					</mx:HBox>
				</mx:VBox>

				<!-- 位置調整のためのスペーサー -->
				<mx:Spacer height="60" />

				<mx:Button label="更新履歴を開く" 
					click="this.messengerManager.openHistoryWindow()" 
					keyDown="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" keyUp="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" 
					/>
			</mx:VBox>
		</mx:TabNavigator>
	
		<!-- ボタンのセットのコンテナ -->
		<mx:HBox id="buttonContainer"
			width="100%"
			horizontalAlign="center"
			verticalAlign="middle"
			horizontalGap="30"
			paddingTop="5"
			paddingBottom="5"
			>
			<mx:Button label="OK" 
				click="onOkButtonClick()" 
				keyDown="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" keyUp="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" 
				/>
			<mx:Button label="キャンセル" 
				click="onCloseButtonClick()" 
				keyDown="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" keyUp="EventUtil.onEnterKeyEventDispatchSpaceKeyEvent(event)" 
				/>
		</mx:HBox>
	</mx:VBox>
</mx:Window>
